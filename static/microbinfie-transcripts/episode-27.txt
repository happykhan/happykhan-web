Hello, and thank you for listening to the MicroBinfeed podcast. Here, we will be
discussing topics in microbial bioinformatics. We hope that we can give you some
insights, tips, and tricks along the way. There is so much information we all
know from working in the field, but nobody writes it down. There is no manual,
and it's assumed you'll pick it up. We hope to fill in a few of these gaps. My
co-hosts are Dr. Nabil Ali Khan and Dr. Andrew Page. I am Dr. Lee Katz. Both
Andrew and Nabil work in the Quadram Institute in Norwich, UK, where they work
on microbes in food and the impact on human health. I work at Centers for
Disease Control and Prevention and am an adjunct member at the University of
Georgia in the U.S. Hello. Welcome to a new thing we are doing called Software
Deep Dives, where we interview the author of a bioinformatics software package.
Today, we are having a chat about some of the software we have created
ourselves, because behind all of our software are quirky details that never make
it to the final paper. Today, Andrew is in the hot seat with Snipsites. So,
first, Andrew, what problem does the software solve? Well, I think it's pretty
self-explanatory. You know, you have a FASTA file, and you want to find out
where all the snips are. As input, you take in a multi-FASTA alignment, and
often you might generate these, say, if you want to build a phylogenetic tree,
or if you're maybe looking for recombination, that kind of thing. So you might
have aligned some of your data against a reference, built consensus, or maybe
you did a whole genome alignment, or even just a gene alignment. And you want to
know, where are the differences, you know? Where is it the same? Where is it
different? And just give me the interesting bits and get rid of the rest. So
that's what Snipsites does at its heart. It does one simple thing. You give it a
load of data, and it gives you the snips. And it's not that complicated, but it
does it really well. You mentioned recombination. But I remember that some other
software you have is called Gubbins, and it deals with recombination. Is there a
relationship? Yeah. So originally, I wrote the software, Gubbins, and then kind
of, when we're halfway through, someone said, well, actually, this little snip
calling part is quite useful in its own right. So could you just take that and
make it a separate application? So that's exactly what I did. I spun out of
Gubbins, copied and pasted some C code, and made a brand new application. And
it's done quite well. So that was Simon Harris who asked for that. And I think
we started to work back in 2013. So you know, a very, very long time ago in the
bioinformatics world. Even for me, it's been very useful over the years. It's
something I use maybe once or twice a month, simply because it does exactly what
it says in the tin, and you get data quickly without any fuss. It's not trying
to do every possible different thing. It's not a complex bioinformatics
pipeline. It's literally just, it's just give me some snips from my file. Sounds
like a very simple procedure. Why would we use snip sites? What are the unique
selling points of this particular implementation? Well, to be honest, when this
came about, everything else that was out there would say load a file into
memory, and then pull out a variance from there. But this is really memory
inefficient. And particularly when you start getting very large files, if you
have like tens of thousands of genomes you're trying to compare, it just becomes
too big for one laptop or one desktop to actually hold it in memory. And it
takes forever as well, because you got to read this stuff in maybe in totally
inefficient Python or C or Python or Perl. So what this does is it's super
memory efficient. The file is read twice. Okay. So not ideally can't stream data
in, but it means that the memory overhead is very, very, very low. of samples
and only use, you know, tens of megabytes of, of memory, which means that, you
know, if you, you're not using much memory, everything is much faster because
moving data around is much easier. It's written in C as well, like proper
handcrafted old school C where I've got to manually manage the memory and all of
that, which is quite different from when you write in Perl or Python, because C,
C is really good, but it's probably not the easiest to learn or to write in. I
noticed that you're bashing Perl again. What's up with that? I love Perl, but
you know, it has a time and a place. And if you're trying to compare two
different things, C is probably the best possible language to write things in
because you're getting way down into the internals of the machine. And you can
just go and make super, super efficient code. You don't have to go through
multiple different layers of libraries and that kind of thing. So that's why I
like it. However, a guy who's up beside me, Ben Taylor, said, Oh yeah, sure. I
can do that in a few hours. It's Cyton. And I was like, what the hell is Cyton?
And it's like, you can compile Python down to C and it runs it super fast. And
so off he goes, he did PySnipSites and in a few hours, he made a very, very,
very fast Python or Cyton implementation that, you know, could have saved me
weeks or months of time had I just done that in the first place. But you know,
there was a few quirks or whatever that made it less good, but it just proves
that maybe you should have a look around first and see is there other ways you
can do it because man hours is also important as well as efficiency. So fair
play to him. But one of the things I'm proud of is that even though it is C, it
does have tests and it's also packaged up very well. So use automake, autoconf,
that kind of thing. So you can just do like a standard way of compiling. You
type in like autoreconf and then configure and make, you know, all of these
standard things you can do, make, install. And by doing that, it is a little bit
of extra effort, but it does mean that your code is very, very platform
independent and you can run that on any Linux or Unix type system without any
hassle really, to be honest. So once it's in there, because we've done all of
this work up front to package it up, we're able to then put into Debian Med,
which is, I suppose, you know, you're doing your apt-get, that kind of thing on
Ubuntu or on Debian. And once it's in there, you know, it's in there forever,
more or less, because they'll continue to maintain it, which is fantastic
because it just means that there's a huge number of distros out there where you
can just type apt-get snipsites and it just goes and installs and you don't have
to worry about anything. It's just magically there. But also, you know, it's in
Homebrew and Conda and Docker and all of this kind of jazz. So it's trivial to
install. I'd say if you haven't done it already, check it out and install it.
Yeah, so actually I just checked it out and installed it just before this chat.
And I should say it was one of the easiest things I've ever run and the most
informative. And I have something similar that I wrote into LiveSet for
distilling snips from a multiple sequence alignment. And I wish I just saw this
and I could have saved on my own man hours. So it was incredible. Well done.
Thank you very much. Actually, for me, I think one of the most useful things in
there is that it can read in gzip files. So you can have your gzipped or
compressed FASTA file, multi-FASTA alignment, and then it just reads it in and
pops out a result. I hate when programs don't take in zipped files. Yeah, I
should point out that it's really important to take the effort to having
software that can be compiled natively, because in principle, that should be
ensuring that you're getting the fastest performance possible. And with
something like this, something you're doing routinely, that time does add up in
the long run. So, yeah, it's really, really great you took the time to do that.
Thank you. So one thing I use it a lot for is just creating VCF files. So, you
know, you pop in your multi-FASTA alignment and then out comes a VCF file and
it'll specify where all of the coordinates of where all the SNPs are and then
gives you a matrix telling you which are the variants and which are not, which
is really, really useful. And I use that all the time for looking at data sets.
But also you can output in like file format, which is this really old, obscure
format. I think Raxomel was the only one I ever noticed that actually still used
it. But, you know, that's a step that a lot of people take. It is to build trees
and you won't get the best trees in the world if you run zip sites. But it is a
quicker way of doing things, because if you give like a one gig file to Raxomel
or to other tree building programs, they often can kind of just fall over or
take forever. Whereas if you just shrink it down to just the SNP sites to the
variants, pop it in and leave your results really quick. Now, it'll be missing
some information, but the branch lengths won't be as good. But at least you'll
get a quick idea of how things cluster. So it's good for that. All right. So
since we asked in the introduction, do you have any behind the scenes quirks or
any insider stories about SNP sites? Well, I thought, OK, let's have a test and
see. Can you publish something? Right. Not even not even being totally serious.
You know, I thought, oh, yeah, we'll see. Can we turn this into a publication?
And will someone actually accept it? Turns out, yes, is the answer. And we got
it accepted in MGen. And it's actually the highest cited paper in MGen, which
is.  a bit crazy for something that we didn't even think would be publishable.
But actually, you know, when you get into the nitty gritty, okay, we did
performance comparisons and whatnot, and we wrote it up properly, but it just
proves that you can pretty much publish anything. Well, not just anything, it's
good software. I wouldn't knock it, but this is really cool. But anyway, the
things I'm really, that I spent the most time on were keep the memory usage
absolutely to the minimum and keeping the speed fast. And I spent a lot of the
time, you know, tracking down memory leaks with Valgrind and things like that.
You know, it's hard work, but see, my God, Python is so much easier, but you
know, it's a trade-off. It's been integrated into quite a few pipelines as well.
I know it's a standard part of many, many, many pipelines from reading who's
referenced it, because it's, you know, it's a simple building block. It works,
it's easy to install. Yeah, it's a very Unix way of thinking at it, the same way
we pipe from one program to the other, or said snip sites, that sort of thing.
Absolutely, yeah. And I think if we had more software like that, that would be
great, because you could just stitch together a pipeline to suit your needs in
minutes, just piping one thing to the other. Absolutely, but I suppose some
people get caught up with having the old singing, old dancing program. And I
suppose I can see how it happens. You know, your boss comes in and says, oh,
could you just do this one little thing? Or a user says, oh yeah, well, I'd like
this, you know, obscure format, and I really want it to be in this color, and I
want to be able to resize it in this way. And it's like, well, you know, two
months later, your code base has tripled, and yeah. Feature creep is a very
insidious problem, and we often learn the hard way that, yeah, feature creep is
something we need to actively combat against. It can be hard to say no
sometimes, though. It can, it can, yeah. Anyway, I don't think I will add any
more to Snip Sites. I think it's as good as it is, and as good as it's gonna
get. Maybe, you know, people want to add more Apple formats. That's probably the
only thing I could see, or bug fixes, whatever. But Torsten, who we all know
very well, went and created Snip Discs, which takes basically the output of what
comes out of Snip Sites, and then it'll do a pairwise comparison and give you a
beautiful distance matrix, which you can then use for seeing which samples are
in common, or which samples have Snips in common, which ones have, which ones
are different. And that's quite a nice little way for interrogating your dataset
very quickly. I suppose you could put trees out of that, couldn't you? Yeah, you
could bang it straight into a neighbor joining for that. It's quite good, and
Torsten's software, as well, is nice and simple, and it just works. Well, thanks
for a great discussion. This was a quick chat about some of the software we've
created ourselves. There's always some interesting facts about how these
different tools came into being. Today, we're talking about Snip Sites, which is
for fetching out Snips from a multi-fasta alignment. You can check it out on
GitHub, and that will be in the show notes. And that's all the time we have for
this episode. See you next time. Thank you all so much for listening to us at
home. If you like this podcast, please subscribe and like us on iTunes, Spotify,
SoundCloud, or the platform of your choice. And if you don't like this podcast,
please don't do anything. This podcast was recorded by the Microbial
Bioinformatics Group and edited by Nick Waters. The opinions expressed here are
our own and do not necessarily reflect the views of CDC or the Quadrant
Institute.