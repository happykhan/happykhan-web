Hello, and thank you for listening to the MicroBinfeed podcast. Here we will be
discussing topics in microbial bioinformatics. We hope that we can give you some
insights, tips, and tricks along the way. There's so much information we all
know from working in the field, but nobody really writes it down. There's no
manual, and it is assumed you'll pick it up. We hope to fill in a few of these
gaps. My co-hosts are Dr. Nabeel Ali Khan of Enterobase, BreakTree, and
BreakFame, and Dr. Andrew Page of such works as Plasmatron 5000, Rory, and
Govince. I am Dr. Lee Katz, and you might know me from my tree-making pipeline,
MassTree, or my SNP pipeline, Liveset. Both Nabeel and Andrew work at the
Quadram Institute in Norwich, UK, where we work on microbes in food and the
impact on human health. I work at the Centers for Disease Control and Prevention
and am an adjunct professor at the University of Georgia in the U.S. Guys,
whenever we go online and we talk about Perl or Python, someone is always
talking trash about Perl or Python, and here's maybe an innocent question,
should I learn Perl or Python when I first start off learning bioinformatics?
Hello and welcome to MicroBinFeed podcast, here we're going to be discussing
should I learn Perl or Python, and maybe some other questions not to ask. Yeah,
I think, so this is a question I think we've all had from the past from people
who are just getting started, and they see a lot of information about Perl and a
lot of information about Python in terms of bioinformatics, and they simply ask,
which is better? And that is a very loaded question, depending who you talk to,
so just if nobody knows, what is Perl? Well, Perl is this really old language,
and it's fantastic for, I suppose, doing text munging, and Perl can give you a
lot of stuff, but then it's a bit messy if you don't do it properly, so a bit of
a trade-off there. And then Python is this beautiful, more modern language,
which is object-oriented, and it's a lot prettier, there's only one way to do
things, whereas with Perl there's about a million ways to do things, so they're
slightly different, and Perl is seen as, I suppose, more of an older language,
it's the first language that got embedded in bioinformatics, whereas Python is
just more of a recent addition. I think Python is older, but yeah, certainly, I
think there's been a switch in the last few years away from Perl to Python,
Python is definitely more popular with people my age, I suppose. Oh, you're
showing your age now? Are you calling us old? Okay, well we should first clear
that up, who is a Pythonista or a Perl person? Well I've done quite a lot of
Perl in my time, but it's one of about a dozen languages I've programmed in my
time, because I come from a software engineering background, and I've been
programming for about 20 years, so you can probably guess my age from that, so I
started off doing a lot of Perl, and now I've moved into Python, but for me, it
makes no difference what language you're programming, as long as you have the
same kind of fundamental things behind you, you know, you can apply it to any
programming language. And what about you, Lee? I've been doing Perl since 2004,
it was basically told to us in grad school, here's the programming language that
you should learn, this is Perl, everyone's learning it, and go. And we had to
basically learn it on our own, in class and in the lab, and on our projects.
Well I think for myself, I started off, so I did software engineering in
undergrad, and that was Java, but the first thing they told us was, don't worry
about the language, it's got nothing to do with the language. It's really about
the conceptual problem you're trying to solve with your programming. And so I
did a lot of Java, then I did Perl in the first two years of my PhD, it's like
when I first started doing bioinformatics, because that was the lab lingua
franca, and then when I was more comfortable, I switched over to Python, and
haven't really looked at Perl code since. So I mean, I made the switch over from
Perl to Python because I thought, okay, I can see Perl is kind of dying off now,
so I might as well force myself to move into Python, which is a lot prettier and
all that. But I've done a lot of Perl in a different style to more traditional
Perl, whereas I've gone and used modern Perl, and objects, and unit testing, and
distzilla for packaging up all the code into an easily installable thing, so it
looks quite different to a lot of the hacky Perl, which people are more familiar
with. Yeah, I really like the way that you program in Perl. I never moved on
myself to Python, I've tried it a few different times, but what I did in the end
was just force myself to write prettier Perl. That's good. I think that's, I
think no matter what language it is, bad code is bad code, you can write, and no
language, no syntax is going to prevent you from writing like absolute
abominations. But Lee, why do you stick with Perl then, since everyone's made
the switch? And Perl is dead, isn't it? People like to tell me that a lot, it's
dead, and I keep programming in it, so it must be alive. I think that the big
thing is that people like to say that it's dead because they hate looking at
Perl code, it's always messy whenever someone sees it. And what I did was I just
forced myself to write in a really nice manner, I picked up a nice coding style
from another fellow graduate student at Georgia Tech, and I can post a link to
my blog on how I wrote on that in the show notes. But I don't know, then how do
other people look at it? I think that they look at the dwindling CPAN releases.
So I saw this blog article one time in August that just like graphed how many
people are posting to CPAN, the Perl repository, versus PyPy, the Python
repository, and currently it looks like it's about 20 to 30 daily uploads to
CPAN versus 7 to 800 daily uploads to PyPy, which is incredible. That means that
people are developing less on Perl. On one hand, some people are thinking that
that means that it's becoming more mature. On the other hand, people are just
saying like people are just developing less and then maybe people are switching
more over to Python. Most of the Perl code that people in bioinformatics think
about is not in CPAN, it's just these hacky scripts, you might have 500 lines
with no comments and it's all just one big blob, whereas a lot of the stuff in
CPAN is much more engineered and is proper professional software. That's a good
point. So along those lines, I would say, I'll challenge you all to just kind of
discuss the bio library in any given language. So the professional piece of code
for bioinformatics usually is BioPerl for Perl, when we're talking or there's
some other more minor ones, usually under the BioX module domain. And so BioPerl
is just like what we use usually when we're programming in Perl and
bioinformatics. What about Python? Yeah, Python is BioPython and that's
phenomenally useful, but still it's missing things that BioPerl has. Lee, what
do you think about Perl 6? It's been coming for about 20 years as far as I
remember. But because it's called Perl 6 versus what we have as Perl 5, like
people keep bringing it up and I have nothing to do with it. And I really like
this blog post that we can also put in the show notes where people are basically
saying, okay, Perl 6 was supposed to be a successor of Perl 5, but it's changed
so much and Perl 5 has a different everything, such legacy code and everything
that, okay, we're just going to call Perl 6 RACU and now it's a different
language. That's a good idea. Yeah, it's a great idea. So I think that it's
great. I think people should probably check out RACU. I just haven't done that
myself. I can again point you to the show notes. Awesome. So Python, I mean, the
first thing that comes to mind actually for me is should you learn Python 2 or
Python 3? Well, when it comes to Python, Python 2 is dead as of the end of this
year and there's actually a countdown clock and everything for it. But
unfortunately, quite a lot of automatic software, as you know, comes from PhD
projects and postdoc projects and then people leave it and then it's never
touched again, which means that a lot of code out there is going to be in a
pretty bad state come the end of this year when Python 2.7 stops being
supported. But of course, it's not going to go away immediately. It just means
that it will slowly decline and things will just slowly stop working. So why do
people use Python 2 at all right now if it's going to go away this year? For a
variety of reasons. You know, if you've started a project in Python 2, you just
continue to do it or perhaps that's the variant you learned. There's only minor
differences, really, but they make all the world of difference. You know, the
most obvious one is, say, the print statement. You need brackets in Python 3,
whereas in Python 2, you don't. And there's other little minor things. But
Python 3 overall is much more stable and it has some really neat features. So I
would go for that one. I think before there was a fair bit, I mean, because
people had to change a lot of the modules over from Python 2 to Python 3, and
that was taking a fair bit of time. If you look at Python 3, like maybe two
years ago or something, you'd find a lot of the modules that you depend on
weren't available. And so then you'd sort of stick with 2. But now I'm yet to
find a module that isn't Python 3 ready. So that excuse doesn't apply anymore.
But that would be one of the reasons why people would have been holding back as
well. So Python is very useful, particularly I found PyPy is just amazing. It is
in a similar way to a CPAN. It's just a repository of libraries and code that
you can just go and install stuff from. I suppose the only downside I find with
it is it doesn't run unit tests. And so you can download a lot of stuff that's
kind of broken as well. So you have to be...  a little bit careful with it. Lee,
what's your opinion of Python from a Perl perspective? Okay, I don't like to use
Python. It actually forces me to use a certain style and I don't like to do
that. But on the other hand, I think that it's wonderful because everyone's on
the same page with the styles that immediately makes it readable. Is this a
whitespace thing? No, it's actually not a whitespace thing. I do like the
whitespace, it's fine. You're a hippie, really. But the problem is like no
closing brackets. You just kind of have to, so maybe it's an issue of having to
like actually make sure you read the whitespace appropriately between like
subroutines or functions. And I don't particularly like learning all the
different modules. Like if I want to exit, then I have to do something like
sys.exit or something. That's weird to me. Just wait till you see Java. Java is
just insane compared to Python in terms of complexity. Like when I first started
learning it, you have to type about 10 different things just to get a simple
command, take input from a keyboard, that kind of thing. It's a lot less usable.
Yeah, I tried. Actually, I also tried Java for a little bit and I hated it. I
had to go into NetBeans and I had to click a button or something and it made all
my getters and setters. Like you have to actually like automate making it so
that you can get rid of all this mundane stuff in Java. I hate it. Yeah, it has
to be automatic, which Python does very well. You know, you have the convention
with underscore, underscore denoting a private method and then not. It's quite a
nice way to do it. I don't know what you guys are talking about. Public static
void main args makes perfect sense. Oh, but I will say some nice things about
Python though. Like I really do like, first of all, okay, it's readable all the
time. Love that. Another thing I like is that any one of your scripts can be
turned into a library automatically. That's really cool. You can import one of
your scripts. If they're written the right way. Yes. Oh, but I have to go back
to bashing it. But, cause I don't like the concurrency. I can't, it has the
global lock. Is that what it's called? The global interpreter lock? Yes. And it
makes it almost impossible to do threads appropriately. Yeah, that is a serious
pain in the butt with Python. I mean, there is a way of doing it. You do have to
rely heavily on pools and queues and everything sort of has to be, I mean,
there's nothing, it's not truly parallel because yeah, because of the gill,
everything's sort of done sequentially, but you then have to do it in such a way
that you're alternating within your task. And that's a bit, it's a bit strange.
As a computer scientist, I love this kind of thing because it keeps the mere
mortals out and then keeps me in a job for the rest of my life. So let's make
the barrier as high as possible. Well, one of the, well, I think I'll give a
counterpoint of why I liked Python or why I stuck with it over other languages
is that if you're just starting out and you want to do anything, you can do more
or less whatever you'd want for programming in Python. Probably not as well as
other languages, but you can make a start. Like you can make a start with making
graphs. You're not gonna make it as well as R, but you've got graphing
libraries. You can do stuff with threading, but it's not that great. You can do
with things like web frameworks, like Django and so on, you can build a website.
So everything that you'd wanna do as a generalist language, Python's a good
place to start. And you can make it very fast as well. If you use Cython, you
can literally just write your Python and then it compiles down to C, which is
just phenomenal. I had an experience where I wrote a piece of code and
handcrafted C and then someone, I spent weeks on this and then someone next to
me just wrote it in Cython, a little bit of Python, bang, there you go, compiled
to C and his was just as fast as my C version. So I was pretty annoyed by that.
And you don't necessarily even have to do that. If you're using a lot of the
number crunching libraries like NumPy and SciPy, the underlying code is executed
as baseline C code. It's like super heavily efficient. And so you've just got a
direct line to using those modules and using those algorithms and you don't have
to do any extra compilation, any extra writing on your part. You just go
straight to those when you need it. And yeah, they're as good as the C
libraries. Oh, that's awesome. So what about some of the other languages that
are out there that people use, Lee? Well, I know we have a bunch of programming
languages in front of us. I'm gonna skip straight ahead to Rust because I
decided a while ago I was gonna try to leapfrog ahead. I was kind of done with
trying to learn Python, but I was gonna go straight for that new and shiny Rusty
programming language called Rust. And it is super difficult to get started, but
they have a really great training manual on it. And I promised myself I would go
through it step by step and I did, I didn't skip any steps as I learned it. And
it's awesome. So steep learning curve and the saying goes in Rust, if it can be
compiled, then it will work. Meaning that if you have any misstep, it actually
won't even compile. It's so heavily safeguarded. So on the side of forcing you
to do error checking. But it's fast. Okay. So, well, I don't, I haven't, I'm not
familiar with, I mean, I've heard of, but I'm not familiar with Rust. What is a
language that it's an older language that it would be most similar to? I mean,
that sounds a bit more Fortran, what you're describing. Maybe, I don't have a
lot of experience with Fortran. I see Rust being compared to things like Fortran
and C in terms of speed tests and in terms of everything else. And Rust is,
well, maybe, I don't know if I'm looking at it with rose colored glasses, you
know, but the blogs that I see just show it having a similar benchmark to the
older languages. What's the bio library like? That's a good question. I haven't
used it too much actually, but I know that it's still in development. I know
that people still have critiques on it. I think that the future for it looks
good, but right now it's still being developed is all I can say. I did develop
my own fast Q parser, which I think everyone does for every language, just
because it's a four line format. Absolutely. It's not a four line format, you
should know. Yeah. Sorry, but yeah, that was a good callback. Anyway, but
developing it to read fast Q files was a really good experience for me. And if
anyone wants to check out my FASN set of scripts, we can link to it in the show
notes. Do you guys have any experience with Julia or Go? No, but I've a lot of
experience with Ruby. For about two years, I was doing Ruby on Rails and Ruby.
And that was quite a beautiful language. The only problem I found with that was
it was very memory inefficient. And I remember having conversation with a guy
saying, oh, well, we have to parse this huge file. You know, it's 50 megabytes
and we need, you know, a hundred gigs of RAM. And he just kind of looked at me
going, what are you talking about? You know, just use Perl and you'll use a
teeny tiny fraction of that. Wow. Why is it memory inefficient then? I'm really
curious. Well, I'm going back 10 years now, but just at the time it was built
for websites and things like that, and not necessarily optimized for, say, the
kind of stuff that we do. Okay. On our forum, people are really into Julia too.
There's this guy who seems to discuss it. He created the Mentalist MLST
software. And he says that if you use Julia and you are a fan of neat
programming in Python, he says that it's faster than Python. It's compiled and
it looks really pretty. Have you guys had any experience with it? Well, the
first time I loaded up Julia, it required four gigs of RAM just to get the
command prompt. And then that's my last experience with it. Hopefully it's
improved. I had a look at some of the documentation. It looks really nice for
data scientists, or if you're going in the machine learning route and so on.
Yeah, it looked great. I'm always hesitant about exotic languages though. We can
check that off to just saying that none of us have used Julia and we would be
excited to try it, I guess. Or maybe not if the command line takes four
gigabytes of RAM. I don't know. What about, I mean, we haven't mentioned, the
elephant in the room is obviously things like JavaScript. Everything's on the
web. Why wouldn't we do our bioinformatics in a browser? Well, the problem there
is that conceptually, it's a very different way of programming. And you have to
think about events and all these kind of other things that you wouldn't
normally. And so the complexity of the programming becomes quite substantially
more difficult. Like if you think about programming in general, most of the
scripts we use will have like a for loop and an if statement and pretty much not
much else. Those are the heart of everything. Whereas a JavaScript, if you have
events going back and forth and you're sending bits of data here and there and
you're interacting with different things, then that just blows your mind. And it
is much more difficult for a beginner to get into that. That's true, but you do
get around, it is therefore then inherently built around concurrency. So you get
that for free. Get that, that you don't have to do anything about once you get
your head around it. And I'd just like to say JavaScript and Java are not the
same thing. They're not even remotely alike. But it does bring us on to
something else, which is static versus dynamic typing or compiled versus
interpreted, which is a very big thing. You get a lot, a lot of
bioinformaticians will only have exposure to dynamic or interpreted languages
like Perl or Python, but there is a whole heap of other languages out there like
C, C++, Java, which are where you have to take your code, compile it down to
machine code or byte code and then run it. So it's kind of a two-step process
and you can't do things like change types for easily on the fly.  compared to
Python, which it just kind of compiles as it goes along. What about you, Lee?
Have you learned much on the static end? Like I said, I've been going more into
Rust. But, you know, for anything I do day to day, I stick with Perl. It's just,
it's benchmarked about twice as slow as a compiled language usually, or maybe
three times. But that's on the same level as something like Python or something
like that. And the whole point of using this dynamic coding language is just, it
reduces the human time. Okay, the computer is three times slower, but I also
finished it in an hour. Yeah, that's true, because computer time is very, very
cheap. Yes. But people are very, very pricey. Yeah, we value our time. Well,
that brings us on to another point, which is employability. All these different
languages have different market salaries, and they publish lists of how much
developers earn on average for different programming languages. And say, for
example, PHP will be right down the bottom. It's kind of a mass market, very
easy for people to learn language, and it's mostly used for kind of the web
stuff. But then at the upper end, you have things like Go, and they command
enormous salaries, particularly people who want to go and work for Google, for
example. But actually, I remember back in the day, Go was a different language,
and then Google misappropriated the name. I was very disappointed with that. I
was very confused for years. You know, this obscure language Go has suddenly had
a huge, big resurgence. Now someone invented a new language. Very disappointed.
Wait, so somebody made a different language called Go also? No, there was a
language called Go, and then Google made a second language called Go about 20
years later. Oh my gosh, I had no idea, actually. Yeah, Google should have
learned. But anyway, in terms of salaries, there can be enormous difference. It
could be the difference between earning $30,000 a year and $100,000 a year,
depending on what language you go into. So you have to be careful. But then
there can be short-lived language salary increases, like COBOL was huge around
the year 2000 because, salaries are huge because people had to go back into all
these old banking systems and fix them for the Y2K issue. And people made a lot
of money then, but since then, you know, it hasn't been as profitable.
Interesting. So choose wisely. The other problem, though, is as a manager,
hiring people for all these different languages can be an issue. So I try and
limit the number of languages on my team so that I don't have, like, five
different languages for which I have to hire five different people who can't
work on any of these other projects. It just becomes a nightmare. So you kind of
have to be careful on that other end not to spread yourself too thinly because
no one can be an expert in everything. That's true. Just on that, especially if
you're putting out software that you're expecting to be consumed by the
community or you're working on larger software projects, it's really difficult
if someone's written a bioinformatics script in one of these more obscure
languages or more exotic languages and you're trying to get it packaged and get
it to work and you're not familiar with it and you don't really understand why
it's not working, why the compiler's not working on this architecture or
whatever. And that's quite difficult. I mean, if you want to... These more
standard languages, your Perl, Python, Java, Cs and whatever are much more
amenable to the community. And since everything we're doing now is more about
collaboration, I think it's better to at least stick to the mainline core
languages that people know. Which brings us to a final question, I suppose,
which is, given all of that, will these new languages replace Perl and Python as
the key languages for bioinformatics? Maybe. But we'll see in about 10 years.
Oh, that's a good answer. I was thinking the short answer is no, but after
everything you said, like having to, for example, having to hire COBOL people to
fix old code, who knows? I think you're right, 10 years. Well, if you look at
the physics community, they are all locked into FORTRAN. And FORTRAN is a fairly
old language from, I think, the 70s. So I don't think we're necessarily going to
see a change overnight. I think communities lock into a language and then
everyone agrees informally that this is what we're going to use. And that's
pretty much it. Change is very slow after that, and bioinformatics is very new.
We made, I suppose, the decision to go Perl first and then found Python is a bit
better as a community. And now it seems like we're sticking with that. I think
it would be quite difficult to... I mean, before there wasn't so much
bioinformatics tools or bioinformatics software out there, but now if we had to
switch the entire codebase to some other language, there's such a huge degree of
inertia now that I don't see it moving very quickly to some other language. Not
as quickly as it did, that we saw over a few years a shift from Perl to Python.
I think it'll be much, much longer if we did a similar shift to some other
language now. I think if Perl had kept up expanding the language at a rapid
pace, and if Perl 6 had come along within a few years, maybe we would have all
kind of stayed with Perl. But Python seemed to be the natural progression to get
all that extra functionality that was missing from Perl. I mean, Perl 6 has been
in development hell for, what, 14 years now, I think? A little while, yeah.
Yeah. Yeah, I'm actually very surprised that there was a quick shift. I think
you're right about in a few years. I even... So you mentioned PHP a couple of
times in different contexts. I actually tried to make a shift to PHP at one
point, and people completely ignored it. I think that, number one, people at the
time were into Perl, and number two, PHP is just too obscure for bioinformatics
right now, and people were basically informally locked into Perl at the time,
and now into Python. There was just no reason to use that PHP code. So I did a
lot of PHP during my PhD as a side project doing websites, and I found it to be
a difficult language to program in, and at the root of it appeared to be that
the very basic language had loads of people who could edit and change the
fundamentals of the language, and there's very little control, so it grew
organically, whereas with, say, C or with other programming languages, it's very
much locked down. People discuss any changes in great detail. There's lots of
community engagement before they make even the smallest of change, and PHP
didn't have any of that. The crazy things like the triple equals or about ten
different ways to print something out to the screen, it became a little bit
unwieldy. Hopefully they'll fix it in the intervening years, but yeah, I
wouldn't go with PHP for bioinformatics these days. I forgot about the triple
equals. Good recall. But of course, should we be doing this anyway at all?
Should we be writing scripts, or should we just sit there and bash the keyboard?
Of course, it's a rhetorical question. So are you going back to the old question
of what questions not to ask? I'm just asking more generally. I recall a few
years ago that there was an XKCD comic basically questioning should you go and
automate that task, and it had a comparison between how often you did a task and
how much time you'd shave off. And interestingly, a lot of tasks, which I
thought, oh yeah, I should probably automate that, it will probably not save me
any time in the long run because it would take me longer to write it. So you
have to be, I suppose, careful about what you automate and what you don't
automate because often it's cheaper just to keep on doing it. Good XKCD
reference. Yeah, but that's absolute sacrilege. Why wouldn't you automate
everything? Because I don't have 200 developers at my disposal. But actually
saying that, if you have a community and if everyone in the entire community is
spending five minutes a week doing a task, then actually maybe it should be
automated. So we talked a lot about Perl versus Python versus everything else,
and at first I thought that we were going to go into the direction of this is
just a question not to ask, but there actually is some real importance on which
language to learn, and it seems like the community really is heading straight
for Python or is already there. So I think that was really enlightening, guys,
and thank you so much, everyone else, for listening in. Thank you all so much
for listening to us at home. If you like this podcast, please subscribe and like
us on iTunes or Google Play. And if you don't like the podcast, please don't do
anything. This podcast was recorded by the Microbial Bioinformatics Group. The
opinions expressed here are our own and do not necessarily reflect the views of
CDC or the Quadrant Institute.